## 一、关于Go语言的介绍

### 1.1、Go解决现代编程难题

Go 语言开发团队花了很长时间来解决当今软件开发人员面对的问题。开发人员在为项目选择语言时，不得不在快速开发和性能之间做出选择。C 和 C++ 这类语言提供了很快的执行速度，
而 Ruby 和 Python 这类语言则擅长快速开发。Go 语言在这两者间架起了桥梁，不仅提供了高性能的语言，同时也让开发更快速。

Go 语言的编译器速度非常快，有时甚至会让人感觉不到在编译。所以，Go 开发者能显著减少等待项目构建的时间。

因为 Go 语言内置并发机制，所以不用被迫使用特定的线程库，就能让软件扩展，使用更多的资源。Go 语言的类型系统简单且高效，不需要为面向对象开发付出额外的心智，让开发者能专注于代码复用。Go 语言还自带垃圾回收器，不需要用户自己管理内存。

因为没有从编译代码到执行代码的中间过程，用动态语言编写应用程序可以快速看到输出。代价是，动态语言不提供静态语言提供的类型安全特性，不得不经常用大量的测试套件来避免在运行的时候出现类型错误这类 bug。

goroutine 使用的内存比线程更少，Go 语言运行时会自动在配置的一组逻辑处理器上调度执行 goroutine。每个逻辑处理器绑定到一个操作系统线程上。

通道是一种数据结构，可以让 goroutine 之间进行安全的数据通信。通道可以帮用户避免其他语言里常见的共享内存访问的问题。在其他语言中，如果使用全局变量或者共享内存，必须使用复杂的锁规则来防止对同一个变量的不同步修改。通道这一模式保证同一时刻只会有一个 goroutine 修改数据。

在两个 goroutine 间传输数据是同步的，一旦传输完成，两个 goroutine 都会知道数据已经完成传输。

需要强调的是，通道并不提供跨 goroutine 的数据访问保护机制。如果通过通道传输数据的一份副本，那么每个 goroutine 都持有一份副本，各自对自己的副本做修改是安全的。当传输的是指向数据的指针时，如果读和写是由不同的 goroutine 完成的，每个 goroutine 依旧需要额外的同步动作。


### 1.2、类型系统

Go 开发者使用组合（composition）设计模式，只需简单地将一个类型嵌入到另一个类型，就能复用所有的功能。

在 Go 语言中，不需要声明某个类型实现了某个接口，编译器会判断一个类型的实例是否符合正在使用的接口。

在 Go 语言中，如果一个类型实现了一个接口的所有方法，那么这个类型的实例就可以存储在这个接口类型的实例中，不需要额外声明。

## 二、go语言读取不同数据源实例

### 2.1、package 包

main 函数保存在名为main 的包里。如果main 函数不在main 包里，构建工
具就不会生成可执行的文件。

一个包定义一组编译过的代码，包的名字类似命名空间，可以用来间接访问包内声明的标识符。这个特性可以把不同包中定义的同名标识符区别开。

关键字 import 就是导入一段代码，让用户可以访问其中的标识符，如类型、函数、常量和接口。

所有处于同一个文件夹里的代码文件，必须使用同一个包名。按照惯例，包和文件夹同名。

导入的路径前面有一个下划线，这个是为了让 Go 语言对包做初始化操作（即调用对应包内的所有代码文件里定义的 init() 函数），但是并不使用包里的标识符。程序中每个代码文件里定义的 init() 函数都会在 main() 函数执行之前调用。

从标准库中导入代码时，只需要提供包名。编译器总是从 GOROOT 和 GOPATH 环境变量引用的位置去查找。（目前最新的包管理是使用 gomod）

以小写字母开头的标识符是不公开的，不能被其他包中的代码直接访问。

```go
var matchers = make(map[string]Matcher)
```

matchers 是包级变量。

在 Go 语言中，所有变量都被初始化为其零值。对于数值类型，零值是 0；对于字符串类型，零值是空字符串；对于布尔类型，零值是 false；对于指针，零值是 nil。对于引用类型来说，所引用的底层数据结构会被初始化为对应的零值。**但是被声明为其零值的引用类型的变量，会返回 nil 作为其值。**

切片是一种实现了一个动态数组的引用类型。

简化变量声明运算符（:=）声明一个变量，同时给这个变量赋予初始值。编译器使用函数返回值的类型来确定每个变量的类型。如果提供确切的非零值初始化变量或者使用函数返回值创建变量，应该使用简化变量声明运算符。

通道（channel）、映射（map）、切片（slice）都是引用类型。

在 main 函数返回前，清理并终止所有之前启动的 goroutine。编写启动和终止时的状态都很清晰的程序，有助减少 bug，防止资源异常。

WaitGroup 是一个计数信号量，我们可以利用它来统计所有的 goroutine 是不是都完成了工作。

关键字 range 可以用于迭代数组、字符串、切片、映射和通道。使用 for range 迭代切片时，每次迭代会返回两个值。第一个值是迭代的元素在切片里的索引位置，第二个值是元素值的一个副本。

下划线还有占位符的作用。

```go
for, _ := range feeds {

}
```

查找 map 里的键时，有两个选择：要么赋值给一个变量，要么为了精确查找，赋值给两个变量。赋值给两个变量时第一个值和赋值给一个变量时的值一样，是 map 查找的结果值。如果指定了第二个值，就会返回一个布尔标志，来表示查找的键是否存在于 map 里。如果这个键不存在，map 会返回其值类型的零值作为返回值，如果这个键存在，map 会返回键所对应值的副本。

一个 goroutine 是一个独立于其他函数运行的函数。使用关键字 go 启动一个 goroutine，并对这个 goroutine 做并发调度。

匿名函数是指没有明确声明名字的函数。匿名函数也可以接受声明时指定的参数。

指针变量可以方便地在函数之间共享数据。使用指针变量可以让函数访问并修改一个变量的状态，而这个变量可以在其他函数甚至是其他 goroutine 的作用域里声明。

在 Go 语言中，所有的变量都以值的方式传递。因为指针变量的值是所指向的内存地址，在函数间传递指针变量，是在传递这个地址值，所以依旧被看作以值的方式在传递。

Go 语言支持闭包，这里就应用了闭包。实际上，在匿名函数内访问 searchTerm 和 results 变量，也是通过闭包的形式访问的。因为有了闭包，函数可以直接访问到那些没有作为参数传入的变量。匿名函数并没有拿到这些变量的副本，而是直接访问外层函数作用域中声明的这些变量本身。因为 matcher 和 feed 变量每次调用时值不相同，所以并没有使用闭包的方式访问这两个变量。

因为 Go 编译器可以根据赋值运算符右边的值来推导类型，声明常量的时候不需要指定类型。

```go
const dataFile = "data/data.json"
```

```json
[
	{
		"site" : "npr",
		"link" : "http://www.npr.org/rss/rss.php?id=1001",
		"type" : "rss"
	},
	{
		"site" : "cnn",
		"link" : "http://rss.cnn.com/rss/cnn_world.rss",
		"type" : "rss"
	},
	{
		"site" : "foxnews",
		"link" : "http://feeds.foxnews.com/foxnews/world?format=xml",
		"type" : "rss"
	},
	{
		"site" : "nbcnews",
		"link" : "http://feeds.nbcnews.com/feeds/topstories",
		"type" : "rss"
	}
]
```

```go
// Feed 包含我们需要处理的数据源的信息
type Feed struct {
	Name 	string `json:"site"`
	URI 	string `json:"link"`
	Type 	string `json:"type"`
}
```

我们声明了一个名叫 Feed 的结构类型。这个类型会对外暴露。这个类型里面声明了 3 个字段，每个字段的类型都是字符串，对应于数据文件中各个文档的不同字段。每个字段的声明最后` 引号里的部分被称作标记（tag）。这个标记里描述了 JSON 解码的元数据，用于创建 Feed 类型值的切片。每个标记将结构类型里字段对应到 JSON 文档里指定名字的字段。
